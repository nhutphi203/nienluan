import mysql from "mysql";
import express from "express";
const router = express.Router();


// K·∫øt n·ªëi database s·ª≠ d·ª•ng pool
const db = mysql.createPool({
    host: process.env.DB_HOST || "127.0.0.1",
    user: process.env.DB_USER || "root",
    password: process.env.DB_PASS || "11111111",
    database: process.env.DB_NAME || "tutoring_center",
    port: process.env.DB_PORT || 3306,
    connectionLimit: 10 // Gi·ªõi h·∫°n s·ªë k·∫øt n·ªëi t·ªëi ƒëa
});

// Ki·ªÉm tra k·∫øt n·ªëi
db.getConnection((err, connection) => {
    if (err) {
        console.error('Error connecting to MySQL:', err);
        return;
    }
    console.log('Connected to MySQL');
    connection.release(); // Gi·∫£i ph√≥ng k·∫øt n·ªëi sau khi ki·ªÉm tra
});

// üìå API: L·∫•y th√¥ng tin c√° nh√¢n h·ªçc vi√™n
router.get("/profile/:id", (req, res) => {
    const studentId = req.params.id;
    const query = "SELECT id, fullName, username, phone, email, role, created_at FROM users WHERE id = ? AND role = 'hv'";

    db.query(query, [studentId], (err, results) => {
        if (err) return res.status(500).json({ error: "L·ªói truy v·∫•n c∆° s·ªü d·ªØ li·ªáu!" });
        if (results.length === 0) return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y h·ªçc vi√™n!" });
        res.json(results[0]);
    });
});
router.get("/available-classes", (req, res) => {
    const sql = `
SELECT 
    c.id, 
    c.name, 
    c.subject, 
    c.type, 
    CASE 
        WHEN c.grade = 1 THEN 10
        WHEN c.grade = 2 THEN 11
        WHEN c.grade = 3 THEN 12
        ELSE c.grade
    END AS grade,
    c.max_student,
    (SELECT COUNT(*) FROM registrations WHERE class_id = c.id) AS current_student,
    GROUP_CONCAT(
        DISTINCT CONCAT(pt.date_of_week, ' (', pt.start_at, ' - ', pt.end_at, ')') 
        ORDER BY FIELD(pt.date_of_week, 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')
        SEPARATOR ', '
    ) AS schedule
FROM class c
LEFT JOIN period_time_class ptc ON c.id = ptc.class_id
LEFT JOIN period_time pt ON ptc.period_time_id = pt.id

GROUP BY c.id, c.name, c.subject, c.type, grade, c.max_student;
    `;

    db.query(sql, (err, results) => {
        if (err) {
            console.error("‚ùå L·ªói khi l·∫•y danh s√°ch l·ªõp h·ªçc c√≤n ƒë·ªß ch·ªó:", err);
            return res.status(500).json({ error: "L·ªói khi l·∫•y danh s√°ch l·ªõp h·ªçc", details: err.message });
        }

        // Map l·∫°i type theo tr√¨nh ƒë·ªô
        const typeMapping = {
            "NORMAL": "L·ªõp c∆° b·∫£n",
            "Advanced": "L·ªõp n√¢ng cao",
            "Math": "L·ªõp √¥n thi h·ªçc sinh gi·ªèi",
            "VIP": "L·ªõp √¥n thi v√†o 10, thi ƒë·∫°i h·ªçc"
        };

        // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu
        const formattedResults = results.map(classItem => ({
            ...classItem,
            type: typeMapping[classItem.type] || classItem.type // N·∫øu kh√¥ng c√≥ trong map th√¨ gi·ªØ nguy√™n
        }));

        res.json(formattedResults);
    });
});


router.get("/classes/:userId", (req, res) => {
    const { userId } = req.params;

    const sql = `
        SELECT 
            c.id, c.name, c.type, c.grade, c.max_student,
            (SELECT COUNT(*) FROM registrations WHERE class_id = c.id) AS current_student,
            GROUP_CONCAT(DISTINCT CONCAT(s.schedule_date, ': ', p.start_at, ' - ', p.end_at) SEPARATOR '; ') AS schedule
        FROM class c
        JOIN schedule s ON c.id = s.class_id
        JOIN period_time p ON s.period_time_id = p.id
        LEFT JOIN registrations r ON c.id = r.class_id AND r.user_id = ?
        WHERE r.user_id IS NULL
        GROUP BY c.id
        ORDER BY c.id;
    `;

    db.query(sql, [userId], (err, results) => {
        if (results.length === 0) {
            return res.status(200).json([]); // ‚úÖ Tr·∫£ v·ªÅ danh s√°ch r·ªóng thay v√¨ l·ªói 404
        }
        if (err) return res.status(500).json({ error: "L·ªói server khi truy v·∫•n d·ªØ li·ªáu" });
        res.json(results);
    });
});// üìå API: ƒêƒÉng k√Ω l·ªõp h·ªçc v√† c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng h·ªçc vi√™n trong l·ªõp
// üìå API: ƒêƒÉng k√Ω l·ªõp h·ªçc v√† c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng h·ªçc vi√™n trong l·ªõp
router.post("/register-group", (req, res) => {
    const { userId, classId } = req.body;

    if (!userId || !classId) {
        console.error("‚ùå Thi·∫øu userId ho·∫∑c classId!");
        return res.status(400).json({ error: "Thi·∫øu userId ho·∫∑c classId!" });
    }

    // üîç Ki·ªÉm tra th√¥ng tin l·ªõp h·ªçc
    const checkClassQuery = `
        SELECT subject, max_student, fee_amount, current_student 
        FROM class 
        WHERE id = ?
    `;

    db.query(checkClassQuery, [classId], (err, classResults) => {
        if (err) {
            console.error("‚ùå L·ªói truy v·∫•n l·ªõp h·ªçc: ", err);
            return res.status(500).json({ error: "L·ªói truy v·∫•n l·ªõp h·ªçc", details: err.message });
        }
        if (classResults.length === 0) {
            return res.status(404).json({ error: "L·ªõp h·ªçc kh√¥ng t·ªìn t·∫°i!" });
        }

        const { subject, max_student, fee_amount, current_student } = classResults[0];

        if (current_student >= max_student) {
            return res.status(400).json({ error: "L·ªõp ƒë√£ ƒë·∫ßy, kh√¥ng th·ªÉ ƒëƒÉng k√Ω!" });
        }

        // üîç Ki·ªÉm tra s·ªë m√¥n h·ªçc ƒë√£ ƒëƒÉng k√Ω
        const checkSubjectsQuery = `
            SELECT DISTINCT c.subject 
            FROM registrations r
            JOIN class c ON r.class_id = c.id
            WHERE r.user_id = ?
        `;

        db.query(checkSubjectsQuery, [userId], (err, subjectResults) => {
            if (err) {
                console.error("‚ùå L·ªói ki·ªÉm tra m√¥n h·ªçc ƒë√£ ƒëƒÉng k√Ω: ", err);
                return res.status(500).json({ error: "L·ªói ki·ªÉm tra m√¥n h·ªçc ƒë√£ ƒëƒÉng k√Ω", details: err.message });
            }

            const registeredSubjects = subjectResults.map(row => row.subject);

            if (registeredSubjects.length >= 3) {
                return res.status(400).json({ error: "B·∫°n ch·ªâ c√≥ th·ªÉ ƒëƒÉng k√Ω t·ªëi ƒëa 3 m√¥n h·ªçc!" });
            }

            if (registeredSubjects.includes(subject)) {
                return res.status(400).json({ error: `B·∫°n ƒë√£ ƒëƒÉng k√Ω m√¥n ${subject} r·ªìi!` });
            }

            // ‚úÖ ƒêƒÉng k√Ω l·ªõp h·ªçc
            const insertQuery = "INSERT INTO registrations (user_id, class_id) VALUES (?, ?)";
            db.query(insertQuery, [userId, classId], (err) => {
                if (err) {
                    console.error("‚ùå L·ªói ƒëƒÉng k√Ω l·ªõp h·ªçc: ", err);
                    return res.status(500).json({ error: "L·ªói ƒëƒÉng k√Ω l·ªõp h·ªçc!", details: err.message });
                }

                // üí∞ C·∫≠p nh·∫≠t h·ªçc ph√≠
                const updateFeeQuery = `
                    INSERT IGNORE INTO student_fee (student_id, class_id, amount, start_at, end_at, is_paid) 
                    VALUES (?, ?, ?, DATE_FORMAT(CURDATE(), '%Y-%m-01'), LAST_DAY(DATE_ADD(CURDATE(), INTERVAL 1 MONTH)), 0);
                `;

                db.query(updateFeeQuery, [userId, classId, fee_amount], (err) => {
                    if (err) {
                        console.error("‚ùå L·ªói c·∫≠p nh·∫≠t h·ªçc ph√≠: ", err);
                        return res.status(500).json({ error: "L·ªói c·∫≠p nh·∫≠t h·ªçc ph√≠!", details: err.message });
                    }

                    // üë• C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng h·ªçc vi√™n trong l·ªõp
                    const updateClassQuery = `
                        UPDATE class SET current_student = current_student + 1 WHERE id = ? AND current_student < max_student;
                    `;
                    db.query(updateClassQuery, [classId], (err) => {
                        if (err) {
                            console.error("‚ùå L·ªói c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng h·ªçc vi√™n: ", err);
                            return res.status(500).json({ error: "L·ªói c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng h·ªçc vi√™n", details: err.message });
                        }

                        res.json({ message: "ƒêƒÉng k√Ω l·ªõp h·ªçc th√†nh c√¥ng v√† h·ªçc ph√≠ ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t!" });
                    });
                });
            });
        });
    });
});




router.get("/registered-classes/:userId", (req, res) => {
    const userId = req.params.userId;

    const sql = `
SELECT 
    c.id, 
    c.name, 
    c.subject, 
    -- üî• √Ånh x·∫° tr·ª±c ti·∫øp lo·∫°i l·ªõp
    CASE 
        WHEN c.type = 'NORMAL' THEN 'L·ªõp c∆° b·∫£n'
        WHEN c.type = 'Normal' THEN 'L·ªõp c∆° b·∫£n 1'
        WHEN c.type = 'Math' THEN 'L·ªõp √¥n thi v√†o 10, thi ƒë·∫°i h·ªçc'
        WHEN c.type = 'VIP' THEN 'L·ªõp √¥n thi h·ªçc sinh gi·ªèi'
        WHEN c.type = 'Advanced' THEN 'L·ªõp n√¢ng cao'
        ELSE 'Kh√°c'
    END AS type_mapped,
    c.grade, 
    c.max_student,
    -- ƒê·∫øm s·ªë h·ªçc vi√™n hi·ªán t·∫°i
    (SELECT COUNT(*) FROM registrations WHERE class_id = c.id) AS current_student,
    -- L·∫•y l·ªãch h·ªçc, gom nh√≥m theo th·ª© t·ª± ng√†y trong tu·∫ßn
    GROUP_CONCAT(
        DISTINCT CONCAT(pt.date_of_week, ' (', pt.start_at, ' - ', pt.end_at, ')') 
        ORDER BY FIELD(pt.date_of_week, 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday')
        SEPARATOR ', '
    ) AS schedule
FROM class c
JOIN registrations r ON c.id = r.class_id
JOIN period_time_class ptc ON c.id = ptc.class_id
JOIN period_time pt ON ptc.period_time_id = pt.id
WHERE r.user_id = ?
GROUP BY c.id, c.name, c.subject, type_mapped, c.grade, c.max_student;


    `;

    db.query(sql, [userId], (err, results) => {
        if (err) {
            console.error("‚ùå L·ªói khi l·∫•y l·ªõp h·ªçc:", err);
            return res.status(500).json({ error: "L·ªói server khi l·∫•y l·ªõp h·ªçc!" });
        }

        // ‚úÖ N·∫øu kh√¥ng c√≤n l·ªõp n√†o, tr·∫£ v·ªÅ danh s√°ch r·ªóng
        return res.status(200).json(results);
    });
});
router.get('/fees/:studentId', (req, res) => {
    const { studentId } = req.params;
    console.log('studentId nh·∫≠n ƒë∆∞·ª£c:', studentId);

    db.query(
        `SELECT 
            c.name AS class_name, 
            sf.class_id, 
            sf.amount, 
            sf.is_paid 
         FROM student_fee sf
         LEFT JOIN class c ON sf.class_id = c.id
         WHERE sf.student_id = ?`,
        [parseInt(studentId)],
        (error, rows) => {
            if (error) {
                console.error('L·ªói khi l·∫•y danh s√°ch h·ªçc ph√≠:', error);
                return res.status(500).json({ success: false, message: 'L·ªói server' });
            }
            console.log('Rows t·ª´ database:', rows);
            res.json(rows);
        }
    );
});


router.post('/pay', (req, res) => {
    const { studentId } = req.body;

    if (!studentId) {
        return res.status(400).json({ success: false, message: 'Thi·∫øu studentId' });
    }

    db.getConnection((err, connection) => {
        if (err) {
            console.error('L·ªói l·∫•y k·∫øt n·ªëi:', err);
            return res.status(500).json({ success: false, message: 'L·ªói server' });
        }

        connection.beginTransaction((err) => {
            if (err) {
                console.error('L·ªói b·∫Øt ƒë·∫ßu transaction:', err);
                connection.release();
                return res.status(500).json({ success: false, message: 'L·ªói server' });
            }

            connection.query(
                'SELECT id, amount FROM student_fee WHERE student_id = ? AND is_paid = 0',
                [studentId],
                (error, result) => {
                    if (error) {
                        console.error('L·ªói truy v·∫•n unpaid fees:', error);
                        connection.rollback(() => {
                            connection.release();
                            res.status(500).json({ success: false, message: 'L·ªói server' });
                        });
                        return;
                    }

                    const unpaidFees = result;

                    if (unpaidFees.length === 0) {
                        connection.rollback(() => {
                            connection.release();
                            res.json({ success: true, message: 'Kh√¥ng c√≥ kho·∫£n ph√≠ n√†o c·∫ßn thanh to√°n' });
                        });
                        return;
                    }

                    connection.query(
                        'UPDATE student_fee SET is_paid = 1 WHERE student_id = ? AND is_paid = 0',
                        [studentId],
                        (error) => {
                            if (error) {
                                console.error('L·ªói c·∫≠p nh·∫≠t is_paid:', error);
                                connection.rollback(() => {
                                    connection.release();
                                    res.status(500).json({ success: false, message: 'L·ªói server' });
                                });
                                return;
                            }

                            const latestPayAt = new Date().toISOString().split('T')[0];
                            let queriesCompleted = 0;
                            const totalQueries = unpaidFees.length;

                            unpaidFees.forEach((fee) => {
                                const alreadyPay = fee.amount;
                                const remaining = 0;

                                connection.query(
                                    'INSERT INTO student_pay_fee (student_id, student_fee, already_pay, remaining, latest_pay_at) VALUES (?, ?, ?, ?, ?)',
                                    [studentId, fee.id, alreadyPay, remaining, latestPayAt],
                                    (error) => {
                                        if (error) {
                                            console.error('L·ªói insert student_pay_fee:', error);
                                            connection.rollback(() => {
                                                connection.release();
                                                res.status(500).json({ success: false, message: 'L·ªói server' });
                                            });
                                            return;
                                        }

                                        queriesCompleted++;
                                        if (queriesCompleted === totalQueries) {
                                            connection.commit((err) => {
                                                if (err) {
                                                    console.error('L·ªói commit transaction:', err);
                                                    connection.rollback(() => {
                                                        connection.release();
                                                        res.status(500).json({ success: false, message: 'L·ªói server' });
                                                    });
                                                    return;
                                                }
                                                connection.release();
                                                res.json({ success: true, message: 'Thanh to√°n th√†nh c√¥ng' });
                                            });
                                        }
                                    }
                                );
                            });
                        }
                    );
                }
            );
        });
    });
});

router.delete("/unregister-group/:studentId/:classId", (req, res) => {
    const { studentId, classId } = req.params;

    db.getConnection((err, connection) => {
        if (err) {
            console.error("‚ùå L·ªói l·∫•y k·∫øt n·ªëi t·ª´ pool:", err);
            return res.status(500).json({ error: "L·ªói k·∫øt n·ªëi c∆° s·ªü d·ªØ li·ªáu!" });
        }

        // B·∫Øt ƒë·∫ßu transaction
        connection.beginTransaction(() => {
            // üîç Ki·ªÉm tra thanh to√°n
            const checkPaymentSql = `
                SELECT COALESCE(SUM(amount), 0) AS total_paid, COALESCE(MAX(is_paid), 0) AS is_paid
                FROM student_fee
                WHERE student_id = ? AND class_id = ?;
            `;

            connection.query(checkPaymentSql, [studentId, classId], (err, paymentResult) => {
                if (err) {
                    connection.rollback(() => connection.release());
                    return res.status(500).json({ error: "L·ªói ki·ªÉm tra thanh to√°n!", details: err.message });
                }

                const totalPaid = parseFloat(paymentResult[0]?.total_paid ?? 0);
                const isPaid = parseInt(paymentResult[0]?.is_paid ?? 0); // ƒê·∫£m b·∫£o ki·ªÉu s·ªë nguy√™n

                console.log("üîç Ki·ªÉm tra thanh to√°n:", { studentId, classId, totalPaid, isPaid });

                // üö® Kh√¥ng cho h·ªßy n·∫øu is_paid = 1
                if (isPaid === 1) {
                    console.log("üö® H·ªßy ƒëƒÉng k√Ω b·ªã ch·∫∑n do ƒë√£ thanh to√°n:", { studentId, classId, totalPaid, isPaid });
                    connection.rollback(() => connection.release());
                    return res.status(400).json({ error: "B·∫°n ƒë√£ thanh to√°n h·ªçc ph√≠, kh√¥ng th·ªÉ h·ªßy ƒëƒÉng k√Ω!" });
                }

                // üîç Ki·ªÉm tra ƒëi·ªÉm s·ªë
                const checkScoreSql = `SELECT COUNT(*) AS count FROM student_scores WHERE student_id = ? AND class_id = ?`;
                connection.query(checkScoreSql, [studentId, classId], (err, scoreResult) => {
                    if (err) {
                        connection.rollback(() => connection.release());
                        return res.status(500).json({ error: "L·ªói ki·ªÉm tra ƒëi·ªÉm!", details: err.message });
                    }

                    console.log("üîç Ki·ªÉm tra ƒëi·ªÉm s·ªë:", { studentId, classId, scoreCount: scoreResult[0].count });

                    if (scoreResult[0].count > 0) {
                        connection.rollback(() => connection.release());
                        return res.status(400).json({ error: "B·∫°n ƒë√£ c√≥ ƒëi·ªÉm, kh√¥ng th·ªÉ h·ªßy ƒëƒÉng k√Ω!" });
                    }

                    // üóë X√≥a `student_fee`
                    const deleteFeeSql = `DELETE FROM student_fee WHERE student_id = ? AND class_id = ?`;
                    connection.query(deleteFeeSql, [studentId, classId], (err, feeResult) => {
                        if (err) {
                            connection.rollback(() => connection.release());
                            return res.status(500).json({ error: "L·ªói x√≥a h·ªçc ph√≠!", details: err.message });
                        }

                        console.log("üóë X√≥a h·ªçc ph√≠:", { studentId, classId, affectedRows: feeResult.affectedRows });

                        // üóë X√≥a ƒëƒÉng k√Ω nh√≥m h·ªçc
                        const deleteRegistrationSql = `DELETE FROM registrations WHERE user_id = ? AND class_id = ?`;
                        connection.query(deleteRegistrationSql, [studentId, classId], (err, deleteResult) => {
                            if (err) {
                                connection.rollback(() => connection.release());
                                return res.status(500).json({ error: "L·ªói khi h·ªßy ƒëƒÉng k√Ω l·ªõp!", details: err.message });
                            }

                            console.log("üóë X√≥a ƒëƒÉng k√Ω:", { studentId, classId, affectedRows: deleteResult.affectedRows });

                            if (deleteResult.affectedRows === 0) {
                                connection.rollback(() => connection.release());
                                return res.status(400).json({ error: "H·ªçc vi√™n kh√¥ng t·ªìn t·∫°i trong nh√≥m n√†y!" });
                            }

                            // üìä C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng h·ªçc vi√™n trong l·ªõp
                            const updateClassSql = `UPDATE class SET current_student = current_student - 1 WHERE id = ?`;
                            connection.query(updateClassSql, [classId], (err, updateResult) => {
                                if (err) {
                                    connection.rollback(() => connection.release());
                                    return res.status(500).json({ error: "L·ªói khi c·∫≠p nh·∫≠t l·ªõp h·ªçc!", details: err.message });
                                }

                                console.log("üìä C·∫≠p nh·∫≠t l·ªõp h·ªçc:", { classId, affectedRows: updateResult.affectedRows });

                                // ‚úÖ Ho√†n th√†nh transaction
                                connection.commit((err) => {
                                    if (err) {
                                        connection.rollback(() => connection.release());
                                        return res.status(500).json({ error: "L·ªói khi x√°c nh·∫≠n transaction!", details: err.message });
                                    }
                                    connection.release();
                                    return res.json({ message: "H·ªßy ƒëƒÉng k√Ω th√†nh c√¥ng v√† ƒë√£ x√≥a h·ªçc ph√≠!" });
                                });
                            });
                        });
                    });
                });
            });
        });
    });
});

router.get("/fees/:studentId", (req, res) => {
    const { studentId } = req.params;

    const query = `
SELECT 
    r.user_id AS student_id,

    -- L·ªõp ƒë√£ thanh to√°n
    COALESCE(GROUP_CONCAT(DISTINCT CASE WHEN sf.is_paid = 1 THEN CONCAT(c.id, ':', c.name) END SEPARATOR ', '), '') AS paid_groups, 
    COUNT(DISTINCT CASE WHEN sf.is_paid = 1 THEN r.class_id END) AS paid_group_count,
    SUM(CASE WHEN sf.is_paid = 1 THEN sf.amount ELSE 0 END) AS total_paid_fee,
    COALESCE(SUM(CASE WHEN sf.is_paid = 1 THEN sf.amount ELSE 0 END), 0) AS already_pay,
    GREATEST((COUNT(DISTINCT CASE WHEN sf.is_paid = 1 THEN r.class_id END) * 500000 
              - COALESCE(SUM(CASE WHEN sf.is_paid = 1 THEN sf.amount ELSE 0 END), 0)), 0) AS remaining_paid,
    MAX(CASE WHEN sf.is_paid = 1 THEN sf.end_at ELSE NULL END) AS last_payment_date,

    -- L·ªõp ch∆∞a thanh to√°n
    COALESCE(GROUP_CONCAT(DISTINCT CASE WHEN sf.is_paid = 0 OR sf.is_paid IS NULL THEN CONCAT(c.id, ':', c.name) END SEPARATOR ', '), '') AS unpaid_groups, 
    COUNT(DISTINCT CASE WHEN sf.is_paid = 0 OR sf.is_paid IS NULL THEN r.class_id END) AS unpaid_group_count,
    COUNT(DISTINCT CASE WHEN sf.is_paid = 0 OR sf.is_paid IS NULL THEN r.class_id END) * 500000 AS total_unpaid_fee,
    0 AS already_unpaid,
    COUNT(DISTINCT CASE WHEN sf.is_paid = 0 OR sf.is_paid IS NULL THEN r.class_id END) * 500000 AS remaining_unpaid

FROM registrations r
LEFT JOIN student_fee sf ON r.user_id = sf.student_id AND r.class_id = sf.class_id
LEFT JOIN class c ON r.class_id = c.id
WHERE r.user_id = ?
GROUP BY r.user_id;




    `;

    db.query(query, [studentId], (err, results) => {
        if (err) {
            console.error("‚ùå L·ªói l·∫•y danh s√°ch h·ªçc ph√≠:", err);
            return res.status(500).json({ error: "L·ªói l·∫•y danh s√°ch h·ªçc ph√≠", details: err.message });
        }
        console.log("üìä K·∫øt qu·∫£ truy v·∫•n h·ªçc ph√≠:", results); // Debug
        res.json(results);
    });

});


router.get("/grades/:student_id/:class_id", (req, res) => {
    const { student_id, class_id } = req.params;

    const getScoresQuery = `
        SELECT class_id, exam_name, score, exam_date 
        FROM student_scores 
        WHERE student_id = ? AND class_id = ?
    `;

    db.query(getScoresQuery, [student_id, class_id], (err, results) => {
        if (err) {
            console.error("‚ùå L·ªói l·∫•y ƒëi·ªÉm:", err);
            return res.status(500).json({ error: "L·ªói server khi l·∫•y ƒëi·ªÉm!" });
        }
        res.json(results);
    });
});


// üìå API: L·∫•y danh s√°ch h·ªçc vi√™n
router.get("/user", (req, res) => {
    const sql = "SELECT id, username AS fullName FROM users WHERE role = 'hv'";
    db.query(sql, (err, results) => {
        if (err) return res.status(500).json({ error: "L·ªói server" });
        res.json(results);
    });
});

export default router;

